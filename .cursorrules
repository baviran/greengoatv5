# Cursor Rules for GreenGoat v5

## üî¥ Critical Rules

### Logging Standards
- **Never use console.log, console.error, console.warn, or console.debug**
- **Always use Logger.getInstance() for logging**
- **Include context object with userId, requestId, component, action when available**
- **Use appropriate log levels:**
  - `debug` for development debugging
  - `info` for business logic and normal flow
  - `warn` for recoverable issues
  - `error` for exceptions and failures

### Logging Context Requirements
```typescript
// ‚úÖ Good - with context
const logger = Logger.getInstance();
const context = {
  userId: user.uid,
  requestId: req.headers.get('x-request-id'),
  component: 'user-service',
  action: 'create-user'
};
logger.info('User created successfully', context, { email: user.email });

// ‚ùå Bad - without context
console.log('User created successfully');
```

### Error Logging
```typescript
// ‚úÖ Good - structured error logging
try {
  // ... code
} catch (error) {
  logger.error('User creation failed', error, context, {
    email: userData.email,
    attemptedRole: userData.role
  });
}

// ‚ùå Bad - console error
catch (error) {
  console.error('User creation failed:', error);
}
```

### Security Rules
- **Never log sensitive data (passwords, tokens, personal info)**
- **Sanitize user input before logging**
- **Use structured logging format: timestamp, level, message, context**

### Performance Rules
- **Use async logging in production environment**
- **Include request tracing with unique request IDs**
- **Log request start/end with duration for API calls**

## üü° API Route Rules

### Authentication Context
```typescript
// ‚úÖ Use enhanced auth middleware
export const POST = withAuth(async (req, authResult) => {
  const { user, context } = authResult;
  const logger = Logger.getInstance().withContext(context);
  
  logger.info('API request started', { endpoint: '/api/users' });
  // ... handler code
});
```

### Request Logging
```typescript
// ‚úÖ Log request lifecycle
export const POST = withRequestContext(async (req, context) => {
  const logger = Logger.getInstance().withContext(context);
  
  logger.requestStart('Processing user request');
  const startTime = Date.now();
  
  try {
    // ... processing
    logger.requestEnd('User request completed', startTime);
  } catch (error) {
    logger.error('User request failed', error);
    throw error;
  }
});
```

## üü¢ Service Layer Rules

### Service Logging
```typescript
// ‚úÖ Component-specific logging
export class UserService {
  private logger = Logger.getInstance().withContext({
    component: 'user-service'
  });
  
  async createUser(userData: CreateUserData, context?: LogContext) {
    const mergedContext = { ...context, action: 'create-user' };
    
    this.logger.info('Starting user creation', mergedContext, {
      email: userData.email
    });
    
    try {
      // ... implementation
      this.logger.info('User created successfully', mergedContext, {
        userId: newUser.id
      });
    } catch (error) {
      this.logger.error('User creation failed', error, mergedContext);
      throw error;
    }
  }
}
```

## üîµ Client-Side Rules

### Client-Side Logging
```typescript
// ‚úÖ Client-side structured logging
const logger = Logger.getInstance();

// For user interactions
logger.info('User interaction', {
  component: 'chat-interface',
  action: 'message-sent',
  userId: user?.uid
});

// For errors
logger.error('Client error occurred', error, {
  component: 'chat-interface',
  action: 'message-failed',
  userId: user?.uid
});
```

## üü£ Migration Rules

### Console.log Replacement
```typescript
// ‚ùå Replace these patterns
console.log('User authenticated:', user.uid);
console.error('Auth failed:', error);
console.warn('Rate limit exceeded');

// ‚úÖ With these patterns
logger.info('User authenticated', { userId: user.uid, component: 'auth' });
logger.error('Authentication failed', error, { component: 'auth' });
logger.warn('Rate limit exceeded', { component: 'rate-limiter' });
```

### Backward Compatibility
- When migrating existing code, maintain original functionality
- Add context progressively - start with component, then add action/userId
- Use `Logger.getInstance().withContext()` for consistent context

## üîç Code Review Checklist

Before submitting code:
- [ ] No console.log/error/warn/debug statements
- [ ] All logging uses Logger.getInstance()
- [ ] Context objects include relevant information
- [ ] Error logging includes error object and context
- [ ] No sensitive data in logs
- [ ] Appropriate log levels used
- [ ] Request tracing implemented for API routes
- [ ] Component and action specified in context
- [ ] API responses use ApiResponseBuilder (never raw JSON)
- [ ] HTTP status codes use HTTP_STATUS constants
- [ ] Request context includes requestId and metadata
- [ ] Error responses include structured error codes
- [ ] Use AppError subclasses for application errors
- [ ] Never throw generic Error objects in business logic
- [ ] Error handling uses ErrorHandler.getInstance() methods

## üöÄ Performance Guidelines

### Production Logging
- Use async logging for better performance
- Include request tracing for monitoring
- Log structured data for better parsing
- Use appropriate log levels to reduce noise

### Development Logging
- Use debug level for detailed debugging
- Include stack traces for errors
- Use pretty printing for better readability
- Log component boundaries for flow tracking

## üîµ API Response Standards

### Response Format Rules
- **Always use ApiResponseBuilder for all API responses**
- **Never return raw JSON objects**
- **Use HTTP_STATUS constants instead of numeric codes**
- **Include request context in all responses**
- **Use structured error codes from ERROR_CODES**

### Success Response Pattern
```typescript
// ‚úÖ Good - unified success response
const successResponse = ApiResponseBuilder.success(userData, context);
return createApiResponse(successResponse, HTTP_STATUS.OK);

// ‚ùå Bad - raw JSON response
return NextResponse.json({ success: true, data: userData });
```

### Error Response Pattern
```typescript
// ‚úÖ Good - structured error response
const errorResponse = ApiResponseBuilder.validationError(
  'Email is required', 
  context, 
  'email'
);
return createApiResponse(errorResponse, HTTP_STATUS.BAD_REQUEST);

// ‚ùå Bad - raw error response
return NextResponse.json({ error: 'Email is required' }, { status: 400 });
```

### Paginated Response Pattern
```typescript
// ‚úÖ Good - structured pagination
const pagination = createPaginationInfo(total, count, limit, offset);
const response = ApiResponseBuilder.paginated(data, pagination, context);
return createApiResponse(response, HTTP_STATUS.OK);

// ‚ùå Bad - manual pagination structure
return NextResponse.json({
  data: data,
  pagination: { total, count, limit, offset, hasMore }
});
```

### Route Handler Pattern
```typescript
// ‚úÖ Good - use withApiResponse middleware
export const GET = withApiResponse('component-name', 'action-name')(
  async (request: NextRequest, authResult: AuthResultWithContext) => {
    const { user, context } = authResult;
    
    // Your logic here
    const data = await getDataFromService();
    
    const response = ApiResponseBuilder.success(data, context);
    return createApiResponse(response, HTTP_STATUS.OK);
  }
);

// ‚ùå Bad - manual auth and response handling
export const GET = withAuth(async (request: NextRequest, authResult) => {
  // Manual response handling without unified format
  return NextResponse.json({ data: result });
});
```

## üîµ Error Handling Standards

### Error Type Rules
- **Always throw AppError subclasses for application errors**
- **Never throw generic Error objects in business logic**
- **Use ErrorHandler.getInstance() for consistent error processing**
- **Include context and details in error objects**

### Error Throwing Pattern
```typescript
// ‚úÖ Good - use specific error types
import { ValidationError, AuthenticationError, NotFoundError } from '@/app/lib/errors/app-errors';

// Validation error
if (!email) {
  throw new ValidationError('Email is required', 'email');
}

// Authentication error  
if (!user) {
  throw new AuthenticationError('User not authenticated');
}

// Not found error
if (!foundUser) {
  throw new NotFoundError('User', userId);
}

// ‚ùå Bad - generic Error
throw new Error('Something went wrong');
```

### Error Handling Pattern
```typescript
// ‚úÖ Good - use ErrorHandler
import { ErrorHandler } from '@/app/lib/errors/error-handler';

try {
  // ... business logic
} catch (error) {
  const errorHandler = ErrorHandler.getInstance();
  return errorHandler.handleApiError(error as Error, context, req);
}

// ‚ùå Bad - manual error handling
catch (error) {
  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
}
```

### Validation Error Handling
```typescript
// ‚úÖ Good - structured validation errors
import { ValidationError, MissingFieldError } from '@/app/lib/errors/app-errors';

const validateUser = (data: any) => {
  if (!data.email) {
    throw new MissingFieldError('email');
  }
  if (!isValidEmail(data.email)) {
    throw new ValidationError('Invalid email format', 'email');
  }
};

// ‚ùå Bad - generic validation
if (!data.email) {
  throw new Error('Email is required');
}
```

### Business Logic Error Handling
```typescript
// ‚úÖ Good - specific business errors
import { BusinessLogicError, ConflictError } from '@/app/lib/errors/app-errors';

if (user.promptCount <= 0) {
  throw new BusinessLogicError('No prompts remaining. Please upgrade.');
}

if (existingUser) {
  throw new ConflictError('User', email);
}

// ‚ùå Bad - unclear business errors
throw new Error('User exists');
```

## üìã Examples

### Complete API Route Example
```typescript
import { withAuth } from '@/lib/auth-middleware';
import { Logger } from '@/app/lib/utils/logger';

export const POST = withAuth(async (req, authResult) => {
  const { user, context } = authResult;
  const logger = Logger.getInstance().withContext({
    ...context,
    component: 'user-api',
    action: 'update-profile'
  });
  
  logger.requestStart('Profile update request');
  
  try {
    const userData = await req.json();
    
    logger.info('Updating user profile', {
      userId: user.uid,
      fields: Object.keys(userData)
    });
    
    const updatedUser = await userService.updateUser(user.email, userData);
    
    logger.info('Profile updated successfully', {
      userId: user.uid
    });
    
    return NextResponse.json({ user: updatedUser });
    
  } catch (error) {
    logger.error('Profile update failed', error, {
      userId: user.uid
    });
    
    return NextResponse.json(
      { error: 'Profile update failed' },
      { status: 500 }
    );
  }
});
``` 